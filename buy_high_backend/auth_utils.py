from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from typing import Optional
import database.handler.postgres.postgres_db_handler as db_handler # Assuming this can be imported
from .pydantic_models import User # Import User Pydantic model
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '../'))
from utils import auth as auth_module

# In a real app, this would come from config
SECRET_KEY = "your-secret-key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 52560000 # 100 years

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/login") # Adjusted to new login path

# Placeholder for current_user. In a real app, this would decode a JWT token.
async def get_current_user(token: str = Depends(oauth2_scheme)) -> User:
    """
    Authenticate user based on Firebase ID token, mock tokens, or test tokens.
    """
    
    # `token` is already the cleaned token from OAuth2PasswordBearer (without "Bearer " prefix)
    print(f"AUTH_UTILS: get_current_user called with token: {token[:50]}...")

    # First try to verify as Firebase ID token (real JWT)
    try:
        print(f"AUTH_UTILS: Attempting Firebase token verification...")
        decoded_token = auth_module.verify_firebase_id_token(token)
        if decoded_token:
            firebase_uid = decoded_token.get('uid')
            print(f"AUTH_UTILS: Firebase token decoded successfully. UID: {firebase_uid}")
            print(f"AUTH_UTILS: Decoded token data: {decoded_token}")
            if firebase_uid:
                user_data = db_handler.get_user_by_firebase_uid(firebase_uid)
                if user_data:
                    print(f"AUTH_UTILS: User found by Firebase UID. User ID: {user_data.get('id')}")
                    return User(**user_data)
                else:
                    print(f"AUTH_UTILS: No user found for Firebase UID: {firebase_uid}")
        else:
            print(f"AUTH_UTILS: Firebase token verification returned None")
    except Exception as e:
        # Log the error but continue to try other token formats
        print(f"AUTH_UTILS: Firebase token verification failed: {e}")
    
    # Try to verify as Google ID token directly (for Google Sign-In tokens)
    try:
        print(f"AUTH_UTILS: Attempting Google ID token verification...")
        decoded_token = auth_module.verify_google_id_token(token)
        if decoded_token:
            google_uid = decoded_token.get('uid')
            print(f"AUTH_UTILS: Google token decoded successfully. UID: {google_uid}")
            print(f"AUTH_UTILS: Google token data: {decoded_token}")
            if google_uid:
                # Try to find user by Google UID (which should be stored as firebase_uid)
                user_data = db_handler.get_user_by_firebase_uid(google_uid)
                if user_data:
                    print(f"AUTH_UTILS: User found by Google UID. User ID: {user_data.get('id')}")
                    return User(**user_data)
                else:
                    print(f"AUTH_UTILS: No user found for Google UID: {google_uid}")
        else:
            print(f"AUTH_UTILS: Google token verification returned None")
    except Exception as e:
        # Log the error but continue to try other token formats
        print(f"AUTH_UTILS: Google token verification failed: {e}")
    
    # Fallback for mock tokens generated by login_firebase_user_rest (e.g., "mock-token-for-mock-uid-user")
    if token.startswith("mock-token-for-"):
        print(f"AUTH_UTILS: Attempting mock token processing...")
        try:
            # Extract "mock-uid-someuser" from "mock-token-for-mock-uid-someuser"
            potential_mock_uid = token[len("mock-token-for-"):]
            print(f"AUTH_UTILS: Extracted mock UID: {potential_mock_uid}")
            if potential_mock_uid: # Ensure it's not empty after stripping
                user_data = db_handler.get_user_by_firebase_uid(potential_mock_uid)
                if user_data:
                    print(f"AUTH_UTILS: User found by mock UID. User ID: {user_data.get('id')}")
                    return User(**user_data)
                else:
                    print(f"AUTH_UTILS: No user found for mock UID: {potential_mock_uid}")
        except Exception as e:
            print(f"AUTH_UTILS: Mock token ('mock-token-for-') processing failed: {e}")
            # Continue to other fallbacks

    # Fallback: Try to parse Firebase UID from custom token format (e.g., "firebase_uid_actualfirebaseuid")
    if token.startswith("firebase_uid_"):
        print(f"AUTH_UTILS: Attempting firebase_uid_ token processing...")
        firebase_uid = token.split("firebase_uid_")[1]
        user_data = db_handler.get_user_by_firebase_uid(firebase_uid)
        if user_data:
            print(f"AUTH_UTILS: User found by firebase_uid_ format. User ID: {user_data.get('id')}")
            return User(**user_data)
        else:
            print(f"AUTH_UTILS: No user found for firebase_uid_: {firebase_uid}")
    
    # Fallback: Try to parse user_id from token (e.g., "user_id_123")
    if token.startswith("user_id_"):
        print(f"AUTH_UTILS: Attempting user_id_ token processing...")
        try:
            user_id = int(token.split("user_id_")[1])
            user_data = db_handler.get_user_by_id(user_id)
            if user_data:
                print(f"AUTH_UTILS: User found by user_id_ format. User ID: {user_data.get('id')}")
                return User(**user_data)
            else:
                print(f"AUTH_UTILS: No user found for user_id_: {user_id}")
        except ValueError as e:
            print(f"AUTH_UTILS: Failed to parse user_id from token: {e}")
    
    # If no valid token format found, raise authentication error
    print(f"AUTH_UTILS: No valid token format found. Raising 401 error.")
    raise HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Invalid authentication token",
        headers={"WWW-Authenticate": "Bearer"},
    )

# Placeholder for a user object that might be available globally in Flask's `g`
# In FastAPI, you get this via Depends(get_current_user)
class AuthenticatedUser(User): # Extends the User Pydantic model
    pass

# Example of how you might structure a more complete get_current_user
# from jose import JWTError, jwt
# async def get_current_user_real(token: str = Depends(oauth2_scheme)):
#     credentials_exception = HTTPException(
#         status_code=status.HTTP_401_UNAUTHORIZED,
#         detail="Could not validate credentials",
#         headers={"WWW-Authenticate": "Bearer"},
#     )
#     try:
#         payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
#         firebase_uid: str = payload.get("sub") # Assuming 'sub' contains firebase_uid
#         if firebase_uid is None:
#             raise credentials_exception
#     except JWTError:
#         raise credentials_exception
#     user = db_handler.get_user_by_firebase_uid(firebase_uid)
#     if user is None:
#         raise credentials_exception
#     return User(**user)
